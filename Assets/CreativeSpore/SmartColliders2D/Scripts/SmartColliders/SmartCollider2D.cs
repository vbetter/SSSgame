using UnityEngine;
using System.Collections;
using System.Collections.Generic;

namespace CreativeSpore.SmartColliders
{

    public struct SmartContactPoint
    {
        // Summary:
        //     Normal of the contact point.
        public Vector3 normal { get; private set; }
        //
        // Summary:
        //     The other collider in contact.
        public SmartCollider2D otherCollider { get; private set; }
        //
        // Summary:
        //     The point of contact.
        public Vector3 point { get; private set; }

        public SmartContactPoint(Vector3 normal, SmartCollider2D otherCollider, Vector3 point)
            : this()
        {
            this.normal = normal;
            this.otherCollider = otherCollider;
            this.point = point;
        }
    }

    /// <summary>
    /// Structure used to get information back from a smart raycast
    /// </summary>
    public class SmartRaycastHit
    {
        /// <summary>
        /// The Collider that was hit.
        /// </summary>
        public Collider collider { get; private set; }
        /// <summary>
        /// The Collider that was hit.
        /// </summary>
        public Collider2D collider2D { get; private set; }
        /// <summary>
        /// The distance from the ray's origin to the impact point.
        /// </summary>
        public float distance { get; set; }        
        /// <summary>
        /// The normal of the surface the ray hit.
        /// </summary>
        public Vector3 normal { get; set; }
        /// <summary>
        /// The impact point in world space where the ray hit the collider.
        /// </summary>
        public Vector3 point { get; set; }
        /// <summary>
        /// The Rigidbody of the collider that was hit. If the collider is not attached
        /// to a rigidbody then it is null.
        /// </summary>
        public Rigidbody rigidbody { get; private set; }
        /// <summary>
        /// The Rigidbody of the collider that was hit. If the collider is not attached
        /// to a rigidbody then it is null.
        /// </summary>
        public Rigidbody2D rigidbody2D { get; private set; }

        public SmartRaycastHit(
                Collider collider,
                Collider2D collider2D,
                float distance,
                Vector3 normal,
                Vector3 point,
                Rigidbody rigidbody,
                Rigidbody2D rigidbody2D
            )
        {
            this.collider = collider;
            this.collider2D = collider2D;
            this.distance = distance;
            this.normal = normal;
            this.point = point;
            this.rigidbody = rigidbody;
            this.rigidbody2D = rigidbody2D;
        }
    }

    public class SmartCollision2D
    {
        /// <summary>
        /// The Collider we hit (Read Only).
        /// </summary>
        public SmartCollider2D collider { get; private set; }
        /// <summary>
        /// The contact points generated by the physics engine.
        /// <summary>
        public SmartContactPoint[] contacts { get; private set; }
        /// <summary>
        /// The GameObject whose collider we are colliding with. (Read Only).
        /// </summary>
        public GameObject gameObject { get; private set; }
        /// <summary>
        /// The total impulse applied to this contact pair to resolve the collision. (Read Only).
        /// </summary>
        public Vector3 impulse { get; private set; }
        /// <summary>
        /// The relative linear velocity of the two colliding objects (Read Only).
        /// </summary>
        public Vector3 relativeVelocity { get; private set; }
        /// <summary>
        /// The Rigidbody we hit (Read Only). This is null if the object we hit is a
        /// collider with no rigidbody attached.
        /// </summary>
        public Rigidbody rigidbody { get; private set; }
        /// <summary>
        /// The Rigidbody2D we hit (Read Only). This is null if the object we hit is a
        /// collider with no rigidbody2D attached.
        /// </summary>
        public Rigidbody2D rigidbody2D { get; private set; }
        /// <summary>
        /// The Transform of the object we hit (Read Only).
        /// </summary>
        public Transform transform { get; private set; }

        public SmartCollision2D(
            SmartCollider2D collider,
            SmartContactPoint[] contacts,
            GameObject gameObject,
            Vector3 impulse,
            Vector3 relativeVelocity,
            Transform transform,
            Rigidbody rigidbody,
            Rigidbody2D rigidbody2D)
        {
            this.collider = collider;
            this.contacts = contacts;
            this.gameObject = gameObject;
            this.impulse = impulse;
            this.relativeVelocity = relativeVelocity;
            this.transform = transform;
            this.rigidbody = rigidbody;
            this.rigidbody2D = rigidbody2D;
        }
    }

    [AddComponentMenu("")]
    public class SmartCollider2D : MonoBehaviour
    {
        public enum eUpdateMode
        {
            OnFixedUpdate,
            OnUpdate
        }

        /// <summary>
        /// OnSmartCollisionStay2D is called once per frame for every SmartCollider that is touching collider.
        /// void OnSmartCollisionStay2D( SmartCollision2D collision )
        /// </summary>
        protected const string k_messageOnSmartCollisionStay2D = "OnSmartCollisionStay2D";
        /// <summary>
        /// OnSmartTriggerStay2D is called once per frame for every SmartCollider other that is touching the trigger.
        /// void OnSmartTriggerStay2D( SmartContactPoint smartContactPoint )
        /// </summary>
        protected const string k_messageOnSmartTriggerStay2D = "OnSmartTriggerStay2D";

        /// <summary>
        /// Gets the rigidBody attached to this collider
        /// </summary>
        public Rigidbody RigidBody { get { return m_rigidBody; } }

        /// <summary>
        /// Gets the rigidBody2D attached to this collider
        /// </summary>
        public Rigidbody2D RigidBody2D { get { return m_rigidBody2D; } }

        /// <summary>
        /// If false, 2D colliders will be skipped when solving collisions
        /// </summary>
        public bool EnableCollision2D = true;
        /// <summary>
        /// If false, 3D colliders will be skipped when solving collisions
        /// </summary>
        public bool EnableCollision3D = true;

        /// <summary>
        /// The Layer Mask of this smart collider with all layers that will be checked when solving collisions
        /// </summary>
        public LayerMask LayerCollision;

        /// <summary>
        /// The layers that will be checked only in up direction
        /// </summary>
        public LayerMask OneWayCollisionUp;
        /// <summary>
        /// The layers that will be checked only in down direction
        /// </summary>
        public LayerMask OneWayCollisionDown;
        /// <summary>
        /// The layers that will be checked only in left direction
        /// </summary>
        public LayerMask OneWayCollisionLeft;
        /// <summary>
        /// The layers that will be checked only in right direction
        /// </summary>
        public LayerMask OneWayCollisionRight;

        /// <summary>
        /// The layers that will move the smart collider when it is touching the physic collider with up side
        /// </summary>
        public LayerMask MovingPlatformCollisionUp;
        /// <summary>
        /// The layers that will move the smart collider when it is touching the physic collider with down side
        /// </summary>
        public LayerMask MovingPlatformCollisionDown;
        /// <summary>
        /// The layers that will move the smart collider when it is touching the physic collider with left side
        /// </summary>
        public LayerMask MovingPlatformCollisionLeft;
        /// <summary>
        /// The layers that will move the smart collider when it is touching the physic collider with right side
        /// </summary>
        public LayerMask MovingPlatformCollisionRight;

        /// <summary>
        /// This is the last solved position free of collision
        /// </summary>
        public Vector3 LastSolvedPosition { get { return m_prevPos; } }

        /// <summary>
        /// Sets the update mode to set during what message the collisions will be checked.
        /// </summary>
        public eUpdateMode UpdateMode { get { return m_updateMode; } set { m_updateMode = value; } }

        [SerializeField]
        protected eUpdateMode m_updateMode = eUpdateMode.OnUpdate;

        /// <summary>
        /// List of moving platform colliders touched by the right side of the smart collider (see MovingPlatformCollisionUp, MovingPlatformCollisionDown, MovingPlatformCollisionLeft, MovingPlatformCollisionRight)
        /// For each platform, an InverseTransformPoint is saved with the inverse of the transform
        /// </summary>
        protected List<KeyValuePair<Transform, Vector3>> m_movingPlatforms = new List<KeyValuePair<Transform, Vector3>>(50);

        /// <summary>
        /// Position of the smart collider after solving collisions in the previous FixedUpdate call
        /// </summary>
        protected Vector3 m_prevPos;

        /// <summary>
        /// Velocity of the smart collider rigid body after solving collisions in the previous FixedUpdate call
        /// </summary>
        protected Vector3 m_prevVelocity;

        /// <summary>
        /// Relative velocity of the smart collider based on the displacement between FixedUpdate calls
        /// </summary>
        protected Vector3 m_instantVelocity;

        /// <summary>
        /// The rigid body of the object containing the smart collider
        /// </summary>
        protected Rigidbody m_rigidBody;
        /// <summary>
        /// The rigid body 2D of the object containing the smart collider
        /// </summary>
        protected Rigidbody2D m_rigidBody2D;

        /// <summary>
        /// Throw a raycast returning a SmartRaycastHit if a collider was found. It includes 2D and 3D colliders
        /// </summary>
        /// <param name="origin"></param>
        /// <param name="direction"></param>
        /// <param name="distance"></param>
        /// <param name="layerMask"></param>
        /// <returns></returns>
        public SmartRaycastHit SmartRaycast(Vector3 origin, Vector3 direction, float distance, int layerMask)
        {
            RaycastHit raycastHit = EnableCollision3D ? _GetClosestHitInfo(origin, direction, distance, layerMask) : default(RaycastHit);
            if (raycastHit.collider != null)
            {
                return new SmartRaycastHit(
                    raycastHit.collider,
                    null,
                    raycastHit.distance,
                    raycastHit.normal,
                    raycastHit.point,
                    raycastHit.rigidbody,
                    null
                    );
            }
            else
            {
                RaycastHit2D raycast2DHit = EnableCollision2D ? _GetClosestHitInfo2D(origin, direction, distance, layerMask) : default(RaycastHit2D);
                if (raycast2DHit.collider != null)
                {
                    return new SmartRaycastHit(
                        null,
                        raycast2DHit.collider,
                        raycast2DHit.distance,
                        raycast2DHit.normal,
                        raycast2DHit.point,
                        null,
                        raycast2DHit.rigidbody
                    );
                }
            }
            return null;
        }

        //NOTE: this method also sends a message to trigger colliders
        protected RaycastHit _GetClosestHitInfo(Vector3 origin, Vector3 direction, float distance, int layerMask, bool sendTriggerEvent = false)
        {
            RaycastHit closestHitInfo = new RaycastHit();
            RaycastHit[] aHitInfo = Physics.RaycastAll(origin, direction, distance, layerMask);
            for (int i = 0; i < aHitInfo.Length; ++i)
            {
                RaycastHit hitInfo = aHitInfo[i];
                if (hitInfo.collider)
                {
                    if (hitInfo.collider.gameObject == gameObject) continue; //skip colliders in this gameobject
                    if (sendTriggerEvent && hitInfo.collider.isTrigger)
                    {
                        hitInfo.collider.gameObject.SendMessageUpwards(k_messageOnSmartTriggerStay2D, new SmartContactPoint(hitInfo.normal, this, hitInfo.point), SendMessageOptions.DontRequireReceiver);
                        continue;
                    }
                }
                if (closestHitInfo.collider == null || closestHitInfo.distance > hitInfo.distance)
                {
                    closestHitInfo = hitInfo;
                }
            }
            return closestHitInfo;
        }

        //NOTE: this method also sends a message to trigger colliders
        protected RaycastHit2D _GetClosestHitInfo2D(Vector3 origin, Vector3 direction, float distance, int layerMask, bool sendTriggerEvent = false)
        {
            RaycastHit2D closestHitInfo = new RaycastHit2D();
            RaycastHit2D[] aHitInfo = Physics2D.RaycastAll(origin, direction, distance, layerMask);
            for (int i = 0; i < aHitInfo.Length; ++i)
            {
                RaycastHit2D hitInfo = aHitInfo[i];                
                if (hitInfo.collider)
                {
                    if (hitInfo.collider.gameObject == gameObject) continue; //skip colliders in this gameobject
                    if (sendTriggerEvent && hitInfo.collider.isTrigger)
                    {
                        hitInfo.collider.gameObject.SendMessageUpwards(k_messageOnSmartTriggerStay2D, new SmartContactPoint(hitInfo.normal, this, hitInfo.point), SendMessageOptions.DontRequireReceiver);
                        continue;
                    }
                }
                //NOTE: hitInfo.fraction is 0 when hit was triggered from inside the collision. I have to skip so this work like 3D ray casting
                if ((closestHitInfo.collider == null || closestHitInfo.distance > hitInfo.distance) && hitInfo.fraction != 0)
                {
                    closestHitInfo = hitInfo;
                }
            }
            return closestHitInfo;
        }
    }
}
